filter(Topic == topics) %>%
select(Name)
column_names <- topic_content$Name
#the first three columns are always the same for every spreadsheet
first_columns <- c("Year", "Council type", "Council")
names_content <- c(first_columns, column_names)
#cross reference names of the spreadsheet with those stated in the Contents
names_identical <- identical(names_sheet, names_content)
#if so, we warn ourselves
if (!names_identical) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has different names that those stated in the Contents"
)
)
}
#read each sheet with minimal  changes
sheet <- readxl::read_excel(filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal",
n_max = 5)
return(sheet)
},
contents = contents)
names(sheets_list) <- sheets_data
return(sheets_list)
}
#we upload the data
resource_consents <- read_excel_sheets(filename = "NMS_complete_dataset_2015-16.xlsx")
warnings()
resource_consents$`1.1 Reviews`
library(naniar)
installed.packages(naniar)
installed.packages("naniar")
installed.packages("naniar")
install.packages("naniar")
library(naniar)
vis_miss(resource_consents)
library(naniar)
vis_miss(resource_consents$`1.1 Reviews`)
?vis_miss
nrow(resource_consents$`1.1 Reviews`)
resource_consents$`1.1 Reviews`
resource_consents$`1.2 Planning`
#Function to acccess a file with multiple spreadsheets and return each sheet as an element of a list
read_excel_sheets <- function(filename) {
#to access the names of the sheets in the data
sheets <- readxl::excel_sheets(filename)
#clean the Contents sheet to use for reference
contents <- readxl::read_excel(filename,
sheet = sheets[2],
skip = 4)
#names of sheets with data
sheets_data <- sheets[3:length(sheets)]
#read each sheet that contains data, and do some sanity checks
sheets_list <- lapply(seq_along(sheets_data), function(X,
contents) {
#Each spreadsheet corresponds to a topic in the Contents sheet
topics <- unique(contents$Topic)[X]
#to deal with an uneven number of rows at the beggining of the sheets, something to fix for the future
skip_lines <-
ifelse(sheets_data[X] == "2.1-2.8 Annual summary", 3, 2)
#access the names of the columns in the spreadsheet
names_sheet <- names(
readxl::read_excel(
filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal"
)
)
#check if there are any duplicated column names
duplicated_names <- sum(stringi::stri_duplicated(names_sheet))
#warn ourselves
if (duplicated_names > 0) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has the following duplicated column names: "
)
)
print(names_sheet[which(stringi::stri_duplicated(names_sheet))])
}
#we access the column names of each topic in the Contents
topic_content <- contents %>%
filter(Topic == topics) %>%
select(Name)
column_names <- topic_content$Name
#the first three columns are always the same for every spreadsheet
first_columns <- c("Year", "Council type", "Council")
names_content <- c(first_columns, column_names)
#cross reference names of the spreadsheet with those stated in the Contents
names_identical <- identical(names_sheet, names_content)
#if so, we warn ourselves
if (!names_identical) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has different names that those stated in the Contents"
)
)
}
#read each sheet with minimal  changes
sheet <- readxl::read_excel(filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal",
n_max = 5)
return(sheet)
},
contents = contents)
names(sheets_list) <- sheets_data
return(sheets_list)
}
#we upload the data
resource_consents <- read_excel_sheets(filename = "NMS_complete_dataset_2015-16.xlsx")
resource_consents$`1.1 Reviews`
filename = "NMS_complete_dataset_2015-16.xlsx"
#to access the names of the sheets in the data
sheets <- readxl::excel_sheets(filename)
contents <- readxl::read_excel(filename,
sheet = sheets[3],
skip = 2)
contents
#to access the names of the sheets in the data
sheets <- readxl::excel_sheets(filename)
#clean the Contents sheet to use for reference
contents <- readxl::read_excel(filename,
sheet = sheets[2],
skip = 4)
#names of sheets with data
sheets_data <- sheets[3:length(sheets)]
#read each sheet that contains data, and do some sanity checks
sheets_list <- lapply(seq_along(sheets_data), function(X,
contents) {
#Each spreadsheet corresponds to a topic in the Contents sheet
topics <- unique(contents$Topic)[X]
#to deal with an uneven number of rows at the beggining of the sheets, something to fix for the future
skip_lines <-
ifelse(sheets_data[X] == "2.1-2.8 Annual summary", 3, 2)
#access the names of the columns in the spreadsheet
names_sheet <- names(
readxl::read_excel(
filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal"
)
)
#check if there are any duplicated column names
duplicated_names <- sum(stringi::stri_duplicated(names_sheet))
#warn ourselves
if (duplicated_names > 0) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has the following duplicated column names: "
)
)
print(names_sheet[which(stringi::stri_duplicated(names_sheet))])
}
#we access the column names of each topic in the Contents
topic_content <- contents %>%
filter(Topic == topics) %>%
select(Name)
column_names <- topic_content$Name
#the first three columns are always the same for every spreadsheet
first_columns <- c("Year", "Council type", "Council")
names_content <- c(first_columns, column_names)
#cross reference names of the spreadsheet with those stated in the Contents
names_identical <- identical(names_sheet, names_content)
#if so, we warn ourselves
if (!names_identical) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has different names that those stated in the Contents"
)
)
}
#read each sheet with minimal  changes
sheet <- readxl::read_excel(filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal",
n_max = 5)
return(sheet)
},
contents = contents)
sheets_list[[1]]
sheets_list[[2]]
library(tidyverse)
library(ggplot2)
library(readxl)
library(stringi)
#improve
#Set working directory to local home
setwd("~/")
#Function to acccess a file with multiple spreadsheets and return each sheet as an element of a list
read_excel_sheets <- function(filename) {
#to access the names of the sheets in the data
sheets <- readxl::excel_sheets(filename)
#clean the Contents sheet to use for reference
contents <- readxl::read_excel(filename,
sheet = sheets[2],
skip = 4)
#names of sheets with data
sheets_data <- sheets[3:length(sheets)]
#read each sheet that contains data, and do some sanity checks
sheets_list <- lapply(seq_along(sheets_data), function(X,
contents) {
#Each spreadsheet corresponds to a topic in the Contents sheet
topics <- unique(contents$Topic)[X]
#to deal with an uneven number of rows at the beggining of the sheets, something to fix for the future
skip_lines <-
ifelse(sheets_data[X] == "2.1-2.8 Annual summary", 3, 2)
#access the names of the columns in the spreadsheet
names_sheet <- names(
readxl::read_excel(
filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal"
)
)
#check if there are any duplicated column names
duplicated_names <- sum(stringi::stri_duplicated(names_sheet))
#warn ourselves
if (duplicated_names > 0) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has the following duplicated column names: "
)
)
print(names_sheet[which(stringi::stri_duplicated(names_sheet))])
}
#we access the column names of each topic in the Contents
topic_content <- contents %>%
filter(Topic == topics) %>%
select(Name)
column_names <- topic_content$Name
#the first three columns are always the same for every spreadsheet
first_columns <- c("Year", "Council type", "Council")
names_content <- c(first_columns, column_names)
#cross reference names of the spreadsheet with those stated in the Contents
names_identical <- identical(names_sheet, names_content)
#if so, we warn ourselves
if (!names_identical) {
print(
paste0(
"Careful! the spreadsheet ",
topics,
" has different names that those stated in the Contents"
)
)
}
#read each sheet with minimal  changes
sheet <- readxl::read_excel(filename,
sheet = sheets_data[X],
skip = skip_lines,
.name_repair = "minimal")
return(sheet)
},
contents = contents)
names(sheets_list) <- sheets_data
return(sheets_list)
}
#we upload the data
resource_consents <- read_excel_sheets(filename = "NMS_complete_dataset_2015-16.xlsx")
library(naniar)
vis_miss(resource_consents$`1.1 Reviews`)
resource_consents$`1.1 Reviews`
vis_miss(resource_consents$`1.2 Planning`)
vis_miss(resource_consents$`1.3 s35 monitoring`)
vis_miss(resource_consents$`1.5 Resource consents`)
vis_miss(resource_consents$`1.5 Resource consents`, warn_large_data = FALSE)
sheets <- readxl::excel_sheets(filename)
filename = "NMS_complete_dataset_2015-16.xlsx"
#
#to access the names of the sheets in the data
sheets <- readxl::excel_sheets(filename)
sheets
sheets[7]
names_sheet <- names(
readxl::read_excel(
filename,
sheet = sheets_data[7],
skip = 2,
.name_repair = "minimal"
)
)
names_sheet <- names(
readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal"
)
)
names_sheet
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal"
)
head(resource_consents)
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal"
)
warnings()
duplicated_names <- sum(stringi::stri_duplicated(names(resource_consents)))
duplicated_names
#Set working directory to where NMS datasheet is located
setwd("~/")
#name of the file to read
filename = "NMS_complete_dataset_2015-16.xlsx"
# Localize the file we are interested int
sheets <- readxl::excel_sheets(filename)
print(sheets)
sheets[7]
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal"
)
warnings()
tibble::deframe(resource_consents)
print(resource_consents, n=Inf)
names(resource_consents)
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal",
guess_max = 10
)
warnings()
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal",
guess_max = 100
)
warnings()
names(resource_consents)
devtools::install_github("tidyverse/readxl")
library(tidyverse)
library(ggplot2)
library(readxl)
library(stringi)
library(naniar)
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal",
guess_max = 2000
)
warnings()
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal",
guess_max = 5000
)
warnings()
#check for duplicate column names
duplicated_names <- sum(stringi::stri_duplicated(names(resource_consents)))
#check  if all of the columns make sense
summary(resource_consents)
#check  if all of the columns make sense
names_resource_consents <- names(resource_consents)
names
names_resource_consents
class(resource_consents)
names_resource_consents
i<-
1
column <- names_resource_consents[i]
column
stringr::str_split(column)
stringr::str_split(column, pattern = " ")
i<-65
column <- names_resource_consents[i]
stringr::str_split(column, pattern = " ")[[1]]
column_type <-rep(NA, length(names_resource_consents))
column_type
decomposed_column <- stringr::str_split(column, pattern = " ")[[1]]
decomposed_column
"Date" %in% decomposed_column
contains_date<- "Date" %in% decomposed_column
contains_year <- "Year" %in% decomposed_column
if(contains_date | contains_year){
column_type[i] <-  "date"
}else{
}
column_type
#it is not guessing right
column_type <-rep(NA, length(names_resource_consents))
for(i in 1:length(names_resource_consents)){
column <- names_resource_consents[i]
decomposed_column <- stringr::str_split(column, pattern = " ")[[1]]
contains_date<- "Date" %in% decomposed_column
contains_year <- "Year" %in% decomposed_column
contains_length <- "Length" %in% decomposed_column
contains_reasons <- "Reasons" %in% decomposed_column
if(contains_date | contains_year){
column_type[i] <-  "date"
}
if(contains_length){
column_type[i] <-  "numeric"
}
if(contains_reasons){
column_type[i] <- "text"
}
}
column_type
summary(resource_consents)
names_resource_consents
contains_date
ccontains_year
contains_year
y_clue <- all(contains_date,
contains_length,
contains_length,
contains_reasons)
y_clue
#it is not guessing right
column_type <-rep(NA, length(names_resource_consents))
for(i in 1:length(names_resource_consents)){
column <- names_resource_consents[i]
decomposed_column <- stringr::str_split(column, pattern = " ")[[1]]
contains_date<- "Date" %in% decomposed_column
contains_year <- "Year" %in% decomposed_column
contains_length <- "Length" %in% decomposed_column
contains_reasons <- "Reasons" %in% decomposed_column
any_clue <- all(contains_date,
contains_length,
contains_length,
contains_reasons)
if(!any_clue){
column_type[i] <- "skip"
}else{
if(contains_date | contains_year){
column_type[i] <-  "date"
}
if(contains_length){
column_type[i] <-  "numeric"
}
if(contains_reasons){
column_type[i] <- "text"
}
}
}
column_type
#it is not guessing right
column_type <-rep(NA, length(names_resource_consents))
for(i in 1:length(names_resource_consents)){
column <- names_resource_consents[i]
decomposed_column <- stringr::str_split(column, pattern = " ")[[1]]
contains_date<- "Date" %in% decomposed_column
contains_year <- "Year" %in% decomposed_column
contains_length <- "Length" %in% decomposed_column
contains_reasons <- "Reasons" %in% decomposed_column
any_clue <- isTRUE(contains_date | contains_year | contains_reasons |contains_year)
if(!any_clue){
column_type[i] <- "skip"
}else{
if(contains_date | contains_year){
column_type[i] <-  "date"
}
if(contains_length){
column_type[i] <-  "numeric"
}
if(contains_reasons){
column_type[i] <- "text"
}
}
}
column_type
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal",
col_types = column_type
)
warnings()
summary(resource_consents)
resource_consents <- readxl::read_excel(
filename,
sheet = sheets[7],
skip = 2,
.name_repair = "minimal"
)
resource_consents %>% as.data.frame()
