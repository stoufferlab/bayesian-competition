growth <- -1 + ((a/b)^(1/b))
env_growth <-   -1 + ((a_env/b)^(1/b_env))
}
# calculate single-species equilibrium densities in control and treatment conditions
equilibrium <- growth/(alphaii*g)
env_equilibrium <- env_growth/(alphaii_env*g)
# create a posterior sample of "more interpretable" model parameters
posterior <-
as.data.frame(
cbind(
lambda,
lambda_env,
alphaii,
alphaii_env,
alphaij,
alphaij_env,
growth,
env_growth,
equilibrium,
env_equilibrium
)
)
# add in the beta parameter if it exists (for completeness)
if("beta" %in% names(model$formula$pforms)) {
posterior$b     <- exp(post$b_beta_Intercept)
posterior$b_env <- exp(post$b_beta_Intercept + post$b_beta_env)
}
# add in the other alpha parameter if it exists (for completeness)
if("alphaik" %in% names(model$formula$pforms)) {
posterior$alphaik     <- post$b_alphaii_Intercept
posterior$alphaik_env <- post$b_alphaii_Intercept + post$b_alphaii_env
}
# add the model name to always be sure
posterior$model <- model$name
return(posterior)
}
multiple_equilibriums <-function(..., s,g) {
models <- list(...)
posteriors <- lapply(models, function(m) {
one_posterior <- posterior_parameters(m,s,g)
return(one_posterior)
}, s=s, g=g)
all_posteriors <- do.call(rbind, posteriors)
}
source("code/gg_theme.R")
source("code/read_models.R")
source("code/model_toolbox.R")
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
#A function that returns a data frame with posterior equilibrium values ofr each models
#modesl is a list of models of the same species
#names is the names of each model, IN THE SAME ORDER as in the list models
#growth functions are the growth functions of each model, in the same order as in the list models
#s and g are the respective survival and germination of each species
multiple_equilibriums <-function(..., s,g) {
models <- list(...)
posteriors <- lapply(models, function(m) {
one_posterior <- posterior_parameters(m,s,g)
return(one_posterior)
}, s=s, g=g)
all_posteriors <- do.call(rbind, posteriors)
}
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, s=si, g=gi)
multiple_equilibriums <-function(..., s,g) {
models <- list(...)
posteriors <- lapply(models, function(m) {
one_posterior <- posterior_parameters(m,s,g)
return(one_posterior)
})
all_posteriors <- do.call(rbind, posteriors)
}
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, s=si, g=gi)
mm
head(mm)
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, vero_hs_multispecies_poisson.rds, s=si, g=gi)
posterior_parameters <- function(model,s,g) {
# extract samples from the model posterior for all parameters
post        <- posterior_samples(model)
# the lambda parameter is in log space and needs transformation
lambda      <- exp(post$b_lambda_Intercept)
lambda_env  <- exp(post$b_lambda_Intercept + post$b_lambda_env)
# intraspecific alphas in control and treatment conditions
alphaii     <- post$b_alphaii_Intercept
alphaii_env <- post$b_alphaii_Intercept + post$b_alphaii_env
# interspecific alphas in control and treatment conditions
alphaij     <- post$b_alphaij_Intercept
alphaij_env <- post$b_alphaij_Intercept + post$b_alphaij_env
# some models and hence "growth rates" include additional parameters
if("beta" %in% names(model$formula$pforms)) {
b     <- exp(post$b_beta_Intercept)
b_env <- exp(post$b_beta_Intercept + post$b_beta_env)
}else{
b     <- NA
b_env <- NA
}
#These definitions are true for all models
a <- lambda*g
a_env <- lambda_env*g
b <- 1 - ((1-g)*s)
#to calculate different growth rates based on the model we define growth based on the name of the model
if (model$name=="Beverton-Holt"){
growth <- (a/b) - 1
env_growth <- (a_env/b) - 1
}
if(model$name=="Lotka-Volterra"){
growth <- 1 - (b/a)
env_growth <- 1 - (b/a_env)
}
if(model$name =="Ricker"){
growth <- log(a/b)
env_growth <- log(a_env/b)
}
if(model$name=="Hassell"){
growth <- -1 + ((a/b)^(1/b))
env_growth <-   -1 + ((a_env/b)^(1/b_env))
}
# calculate single-species equilibrium densities in control and treatment conditions
equilibrium <- growth/(alphaii*g)
env_equilibrium <- env_growth/(alphaii_env*g)
# create a posterior sample of "more interpretable" model parameters
posterior <-
as.data.frame(
cbind(
lambda,
lambda_env,
alphaii,
alphaii_env,
alphaij,
alphaij_env,
growth,
env_growth,
equilibrium,
env_equilibrium
)
)
# add in the beta parameter if it exists (for completeness)
if("beta" %in% names(model$formula$pforms)) {
posterior$b     <- exp(post$b_beta_Intercept)
posterior$b_env <- exp(post$b_beta_Intercept + post$b_beta_env)
}
# add in the other alpha parameter if it exists (for completeness)
if("alphaik" %in% names(model$formula$pforms)) {
posterior$alphaik     <- post$b_alphaii_Intercept
posterior$alphaik_env <- post$b_alphaii_Intercept + post$b_alphaii_env
}
# add the model name to always be sure
posterior$model <- model$name
return(posterior)
}
multiple_equilibriums <-function(..., s,g) {
models <- list(...)
posteriors <- lapply(models, function(m) {
one_posterior <- posterior_parameters(m,s,g)
return(one_posterior)
})
all_posteriors <- do.call(rbind, posteriors)
}
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, s=si, g=gi)
mm
head(mm)
posterior_parameters <- function(model,s,g) {
# extract samples from the model posterior for all parameters
post        <- posterior_samples(model)
# the lambda parameter is in log space and needs transformation
lambda      <- exp(post$b_lambda_Intercept)
lambda_env  <- exp(post$b_lambda_Intercept + post$b_lambda_env)
# intraspecific alphas in control and treatment conditions
alphaii     <- post$b_alphaii_Intercept
alphaii_env <- post$b_alphaii_Intercept + post$b_alphaii_env
# interspecific alphas in control and treatment conditions
alphaij     <- post$b_alphaij_Intercept
alphaij_env <- post$b_alphaij_Intercept + post$b_alphaij_env
# some models and hence "growth rates" include additional parameters
if("beta" %in% names(model$formula$pforms)) {
b     <- exp(post$b_beta_Intercept)
b_env <- exp(post$b_beta_Intercept + post$b_beta_env)
}else{
b     <- NA
b_env <- NA
}
#These definitions are true for all models
a <- lambda*g
a_env <- lambda_env*g
b <- 1 - ((1-g)*s)
#to calculate different growth rates based on the model we define growth based on the name of the model
if (model$name=="Beverton-Holt"){
growth <- (a/b) - 1
env_growth <- (a_env/b) - 1
}
if(model$name=="Lotka-Volterra"){
growth <- 1 - (b/a)
env_growth <- 1 - (b/a_env)
}
if(model$name =="Ricker"){
growth <- log(a/b)
env_growth <- log(a_env/b)
}
if(model$name=="Hassell"){
growth <- -1 + ((a/b)^(1/b))
env_growth <-   -1 + ((a_env/b)^(1/b_env))
}
# calculate single-species equilibrium densities in control and treatment conditions
equilibrium <- growth/(alphaii*g)
env_equilibrium <- env_growth/(alphaii_env*g)
# create a posterior sample of "more interpretable" model parameters
posterior <-
as.data.frame(
cbind(
lambda,
lambda_env,
alphaii,
alphaii_env,
alphaij,
alphaij_env,
growth,
env_growth,
equilibrium,
env_equilibrium
)
)
#because to rbind things they need to have the same number of columsn
posterior$b     <- b
posterior$b_env <- b_env
# add in the other alpha parameter if it exists (for completeness)
if("alphaik" %in% names(model$formula$pforms)) {
posterior$alphaik     <- post$b_alphaii_Intercept
posterior$alphaik_env <- post$b_alphaii_Intercept + post$b_alphaii_env
}
# add the model name to always be sure
posterior$model <- model$name
return(posterior)
}
multiple_equilibriums <-function(..., s,g) {
models <- list(...)
posteriors <- lapply(models, function(m) {
one_posterior <- posterior_parameters(m,s,g)
return(one_posterior)
})
all_posteriors <- do.call(rbind, posteriors)
}
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, s=si, g=gi)
head(mm)
posterior_parameters <- function(model,s,g) {
# extract samples from the model posterior for all parameters
post        <- posterior_samples(model)
# the lambda parameter is in log space and needs transformation
lambda      <- exp(post$b_lambda_Intercept)
lambda_env  <- exp(post$b_lambda_Intercept + post$b_lambda_env)
# intraspecific alphas in control and treatment conditions
alphaii     <- post$b_alphaii_Intercept
alphaii_env <- post$b_alphaii_Intercept + post$b_alphaii_env
# interspecific alphas in control and treatment conditions
alphaij     <- post$b_alphaij_Intercept
alphaij_env <- post$b_alphaij_Intercept + post$b_alphaij_env
# some models and hence "growth rates" include additional parameters
if("beta" %in% names(model$formula$pforms)) {
beta     <- exp(post$b_beta_Intercept)
beta_env <- exp(post$b_beta_Intercept + post$b_beta_env)
}else{
beta     <- NA
beta_env <- NA
}
#These definitions are true for all models
a <- lambda*g
a_env <- lambda_env*g
b <- 1 - ((1-g)*s)
#to calculate different growth rates based on the model we define growth based on the name of the model
if (model$name=="Beverton-Holt"){
growth <- (a/b) - 1
env_growth <- (a_env/b) - 1
}
if(model$name=="Lotka-Volterra"){
growth <- 1 - (b/a)
env_growth <- 1 - (b/a_env)
}
if(model$name =="Ricker"){
growth <- log(a/b)
env_growth <- log(a_env/b)
}
if(model$name=="Hassell"){
growth <- -1 + ((a/b)^(1/b))
env_growth <-   -1 + ((a_env/b)^(1/b_env))
}
# calculate single-species equilibrium densities in control and treatment conditions
equilibrium <- growth/(alphaii*g)
env_equilibrium <- env_growth/(alphaii_env*g)
# create a posterior sample of "more interpretable" model parameters
posterior <-
as.data.frame(
cbind(
lambda,
lambda_env,
alphaii,
alphaii_env,
alphaij,
alphaij_env,
growth,
env_growth,
equilibrium,
env_equilibrium
)
)
#because to rbind things they need to have the same number of columsn
posterior$b     <- beta
posterior$b_env <- beta_env
# add in the other alpha parameter if it exists (for completeness)
if("alphaik" %in% names(model$formula$pforms)) {
posterior$alphaik     <- post$b_alphaii_Intercept
posterior$alphaik_env <- post$b_alphaii_Intercept + post$b_alphaii_env
}
# add the model name to always be sure
posterior$model <- model$name
return(posterior)
}
multiple_equilibriums <-function(..., s,g) {
models <- list(...)
posteriors <- lapply(models, function(m) {
one_posterior <- posterior_parameters(m,s,g)
return(one_posterior)
})
all_posteriors <- do.call(rbind, posteriors)
}
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, s=si, g=gi)
mm
head(mm)
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, vero_hs_multispecies_poisson.rds ,s=si, g=gi)
posterior_parameters <- function(model,s,g) {
# extract samples from the model posterior for all parameters
post        <- posterior_samples(model)
# the lambda parameter is in log space and needs transformation
lambda      <- exp(post$b_lambda_Intercept)
lambda_env  <- exp(post$b_lambda_Intercept + post$b_lambda_env)
# intraspecific alphas in control and treatment conditions
alphaii     <- post$b_alphaii_Intercept
alphaii_env <- post$b_alphaii_Intercept + post$b_alphaii_env
# interspecific alphas in control and treatment conditions
alphaij     <- post$b_alphaij_Intercept
alphaij_env <- post$b_alphaij_Intercept + post$b_alphaij_env
# some models and hence "growth rates" include additional parameters
if("beta" %in% names(model$formula$pforms)) {
beta     <- exp(post$b_beta_Intercept)
beta_env <- exp(post$b_beta_Intercept + post$b_beta_env)
}else{
beta     <- NA
beta_env <- NA
}
#These definitions are true for all models
a <- lambda*g
a_env <- lambda_env*g
b <- 1 - ((1-g)*s)
#to calculate different growth rates based on the model we define growth based on the name of the model
if (model$name=="Beverton-Holt"){
growth <- (a/b) - 1
env_growth <- (a_env/b) - 1
}
if(model$name=="Lotka-Volterra"){
growth <- 1 - (b/a)
env_growth <- 1 - (b/a_env)
}
if(model$name =="Ricker"){
growth <- log(a/b)
env_growth <- log(a_env/b)
}
if(model$name=="Hassell"){
growth <- -1 + ((a/b)^(1/beta))
env_growth <-   -1 + ((a_env/b)^(1/beta_env))
}
# calculate single-species equilibrium densities in control and treatment conditions
equilibrium <- growth/(alphaii*g)
env_equilibrium <- env_growth/(alphaii_env*g)
# create a posterior sample of "more interpretable" model parameters
posterior <-
as.data.frame(
cbind(
lambda,
lambda_env,
alphaii,
alphaii_env,
alphaij,
alphaij_env,
growth,
env_growth,
equilibrium,
env_equilibrium
)
)
#because to rbind things they need to have the same number of columsn
posterior$b     <- beta
posterior$b_env <- beta_env
# add in the other alpha parameter if it exists (for completeness)
if("alphaik" %in% names(model$formula$pforms)) {
posterior$alphaik     <- post$b_alphaii_Intercept
posterior$alphaik_env <- post$b_alphaii_Intercept + post$b_alphaii_env
}
# add the model name to always be sure
posterior$model <- model$name
return(posterior)
}
mm <- multiple_equilibriums(vero_bh_multispecies_poisson.rds, vero_hs_multispecies_poisson.rds ,s=si, g=gi)
head(mm)
nrow(mm)
tail(mm)
vero <- multiple_equilibriums(
vero_bh_multispecies_poisson.rds,
vero_lv_multispecies_poisson.rds,
vero_rc_multispecies_poisson.rds,
vero_hs_multispecies_poisson.rds,
s = si,
g = gi
)
trcy <- multiple_equilibriums(
trcy_bh_multispecies_poisson.rds,
trcy_lv_multispecies_poisson.rds,
trcy_rc_multispecies_poisson.rds,
trcy_hs_multispecies_poisson.rds,
s = sj,
g = gj
)
head(vero)
tail(vero)
trcy$model<-factor(trcy$model, levels = model_names)
vero$model<-factor(vero$model, levels= model_names)
model_names <- c("Beverton-Holt", "Lotka-Volterra", "Ricker", "Hassell")
trcy$model<-factor(trcy$model, levels = model_names)
vero$model<-factor(vero$model, levels= model_names)
vero_0<-ggplot(vero) +
geom_density(mapping = aes(x = equilibrium, fill = model, linetype=model) ,
alpha = 0.8, show.legend = TRUE) +
scale_linetype_manual(values=c("solid","dashed","twodash", "dotted"))+
scale_fill_manual(values=palette_alba)+
theme_alba+
xlim(0,400) +
ylim(0,0.027)
trcy_0<-ggplot(trcy) +
geom_density(mapping = aes(x = equilibrium, fill = model, linetype=model) ,
alpha = 0.8, show.legend = FALSE) +
scale_fill_manual(values=palette_alba)+
theme_alba +
xlim(0,400)+
ylim(0,0.027)
vero_1<-ggplot(vero) +
geom_density(mapping = aes(x = env_equilibrium, fill = model, linetype=model) ,
alpha = 0.8,show.legend = TRUE) +
scale_fill_manual(values=palette_alba) +
theme_alba +
xlim(0,1500)+
ylim(0,0.0125)
trcy_1<-ggplot(trcy) +
geom_density(mapping = aes(x = env_equilibrium, fill = model, linetype=model) ,
alpha = 0.8, show.legend = FALSE) +
scale_fill_manual(values=palette_alba)+
theme_alba +
xlim(0,1500) +
ylim(0,0.0125)
all_figures<-ggarrange( vero_0, trcy_0 ,
labels = c("A", "B"),
ncol = 1, nrow = 2)
all_figures
env_figures<-ggarrange( vero_1, trcy_1 ,
labels = c("A", "B"),
ncol = 1, nrow = 2)
env_figures
head(vero)
source("code/model_toolbox.R")
source("code/feasibility_toolbox.R")
source("code/model_toolbox.R")
source("code/read_models.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
post <- feasibility_wrapper(vero_model = vero_bh_multispecies_poisson.rds, trcy_model = trcy_bh_multispecies_poisson.rds,si = si,gi = gi,sj = sj,gj = gj,env = FALSE)
feasibility_wrapper<-function(vero_model,trcy_model, si, gi, sj, gj, env){
vero_post<- posterior_parameters(model = vero_model, s = si,g = gi)
trcy_post<- posterior_parameters(model = trcy_model ,s = sj,g  = gj)
post <- posterior_feasibility(vero_post = vero_post,trcy_post = trcy_post,gi = gi,gj = gj,env = env)
return(post)
}
feasibility_wrapper<-function(vero_model,trcy_model, si, gi, sj, gj, env){
vero_post<- posterior_parameters(model = vero_model, s = si,g = gi)
trcy_post<- posterior_parameters(model = trcy_model ,s = sj,g  = gj)
post <- posterior_feasibility(vero_post = vero_post,trcy_post = trcy_post,gi = gi,gj = gj,env = env)
post$vero_model <- vero_model$name
post$trcy_model <- trcy_model$name
return(post)
feasibility_wrapper<-function(vero_model,trcy_model, si, gi, sj, gj, env){
vero_post<- posterior_parameters(model = vero_model, s = si,g = gi)
trcy_post<- posterior_parameters(model = trcy_model ,s = sj,g  = gj)
post <- posterior_feasibility(vero_post = vero_post,trcy_post = trcy_post,gi = gi,gj = gj,env = env)
post$vero_model <- vero_model$name
post$trcy_model <- trcy_model$name
return(post)
}
post <- feasibility_wrapper(vero_model = vero_bh_multispecies_poisson.rds, trcy_model = trcy_bh_multispecies_poisson.rds,si = si,gi = gi,sj = sj,gj = gj,env = FALSE)
head(post)
col1 <- rethinking::col.alpha("mediumseagreen", .3)
col2 <- rethinking::col.alpha("grey50", .3)
source("code/gg_theme.R")
ggplot(post) +
geom_point(
mapping = aes(
x = omega_results,
y = theta_results,
col = as.factor(feasibility_results)
),
show.legend = FALSE
) +
theme_alba +
scale_color_manual(values = c(col2, col1))
