return(tt)
}
r_feasible<-function(alpha, rconstraints=NULL, Nupper=NULL, make_plot=FALSE){
R_vals <- c(0.0001,1:100)
r_sample <- t(sapply(
seq_len(1000),
function(x,R_vals,alpha,rconstraints,Nupper){
while(TRUE){
R <- sample(R_vals,1)
theta <- runif(1,0,2*pi)
feas <- feasibility_theta(theta = theta,
R= R,
alpha = alpha,
rconstraints = rconstraints,
Nupper = Nupper)
if(feas){
return(c(R=R,theta=theta,ri=R*cos(theta),rj=R*sin(theta)))
}
}
},
R_vals=R_vals,
alpha=alpha,
rconstraints=rconstraints,
Nupper=Nupper
)) %>% as.data.frame()
if(make_plot){
plot(0,0,
xlim=c(-range(R_vals)[2],range(R_vals)[2]),
ylim=c(-range(R_vals)[2],range(R_vals)[2]),
type='n',
xlab=expression(italic(r[i])),
ylab=expression(italic(r[j]))
)
abline(h=0,lty='dashed',lwd=1.5)
abline(v=0,lty='dashed',lwd=1.5)
apply(r_sample, MARGIN=1,
function(x) {
segments(0,0,x["ri"],x["rj"],col=grey(0.75))
}
)
}
return(r_sample)
}
rconstraints <- list(
lower = c(-Inf, -Inf),
upper = c(Inf, Inf)
)
Nupper <- c(
i = Inf,
j = Inf
)
test<-multiple_omega( diagonal = 1,
off_diagonal = .9,
R = 3,
rconstraints = rconstraints,
Nupper =  Nupper)
integrate_radii <- function(alpha, R ,rconstraints=NULL,Nupper=NULL){
multiple_R <- integrate( f= integrate_theta,
lower = 0,
upper = R,
alpha = alpha,
rconstraints= rconstraints,
Nupper= Nupper)
return( multiple_R[1]$value/R)
#
# R_seq <- seq(0,R, length.out = 1000)
#
# multiple_R <- integrate_theta(R_seq = R_seq,
#                               alpha = alpha,
#                               rconstraints = rconstraints,
#                               Nupper = Nupper)
#
#
# return( sum(multiple_R)/length(R_seq))
}
alpha
rconstraints <- list(
lower = c(-Inf, -Inf),
upper = c(Inf, Inf)
)
Nupper <- c(
i = Inf,
j = Inf
)
test<-multiple_omega( diagonal = 1,
off_diagonal = .9,
R = 3,
rconstraints = rconstraints,
Nupper =  Nupper)
test<-multiple_omega( diagonal = 1,
off_diagonal = .9,
R = 1,
rconstraints = rconstraints,
Nupper =  Nupper)
integrate_theta <-function( R_seq,alpha,rconstraints=NULL,Nupper=NULL ) {
thetas <- seq(0 , 2*pi, length.out = 1000)
results <- sapply(R_seq, function(R, alpha, rconstraints, Nupper){
area<- feasibility_theta(theta_seq = thetas,
alpha = alpha,
R = R,
rconstraints = rconstraints,
Nupper= Nupper)
# area<-integrate(f=feasibility_theta,
#                lower = 0,
#                upper = 2*pi,
#                alpha = alpha,
#                R = R,
#                rconstraints = rconstraints,
#                Nupper= Nupper)
#
print(area)
return(sum(area)/length(thetas))
}, alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
return(results)
}
integrate_theta(R_seq = c(0.1,1), alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
feasibility_theta(theta_seq = c(0, 0.78), alpha = alpha, R=1, rconstraints = rconstraints, Nupper = Nupper)
integrate_theta <-function( R_seq,alpha,rconstraints=NULL,Nupper=NULL ) {
thetas <- seq(0 , 2*pi, length.out = 1000)
results <- sapply(R_seq, function(R, alpha, rconstraints, Nupper){
area<- feasibility_theta(theta_seq = thetas,
alpha = alpha,
R = R,
rconstraints = rconstraints,
Nupper= Nupper)
# area<-integrate(f=feasibility_theta,
#                lower = 0,
#                upper = 2*pi,
#                alpha = alpha,
#                R = R,
#                rconstraints = rconstraints,
#                Nupper= Nupper)
#
# print(area)
return(sum(area)/length(thetas))
}, alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
return(results)
}
integrate_theta(R_seq = c(0.1,1), alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
integrate_theta(R_seq = c(0.1,100), alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
tt<-integrate_theta(R_seq = seq(0.1,100), alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
integrate_theta <-function( R_seq,alpha,rconstraints=NULL,Nupper=NULL ) {
thetas <- seq(0 , 2*pi, length.out = 1000)
results <- sapply(R_seq, function(R, alpha, rconstraints, Nupper){
area<- feasibility_theta(theta_seq = thetas,
alpha = alpha,
R = R,
rconstraints = rconstraints,
Nupper= Nupper)
# area<-integrate(f=feasibility_theta,
#                lower = 0,
#                upper = 2*pi,
#                alpha = alpha,
#                R = R,
#                rconstraints = rconstraints,
#                Nupper= Nupper)
#
print(area)
return(sum(area)/length(thetas))
}, alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
return(results)
}
tt<-integrate_theta(R_seq = seq(0.1,100), alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
tt
integrate_theta <-function( R_seq,alpha,rconstraints=NULL,Nupper=NULL ) {
thetas <- seq(0 , 2*pi, length.out = 1000)
results <- sapply(R_seq, function(R, alpha, rconstraints, Nupper){
area<- feasibility_theta(theta_seq = thetas,
alpha = alpha,
R = R,
rconstraints = rconstraints,
Nupper= Nupper)
# area<-integrate(f=feasibility_theta,
#                lower = 0,
#                upper = 2*pi,
#                alpha = alpha,
#                R = R,
#                rconstraints = rconstraints,
#                Nupper= Nupper)
#
# print(area)
return(sum(area)/length(thetas))
}, alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
return(results)
}
tt
tt<-integrate_theta(R_seq = seq(0.1,100), alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
tt
integrate_radii <- function(alpha, R ,rconstraints=NULL,Nupper=NULL){
multiple_R <- integrate( f= integrate_theta,
lower = 0,
upper = R,
alpha = alpha,
rconstraints= rconstraints,
Nupper= Nupper)
return( multiple_R[1]$value/R)
#
# R_seq <- seq(0,R, length.out = 1000)
#
# multiple_R <- integrate_theta(R_seq = R_seq,
#                               alpha = alpha,
#                               rconstraints = rconstraints,
#                               Nupper = Nupper)
#
#
# return( sum(multiple_R)/length(R_seq))
}
ti<-integrate_radii(alpha = alpha, R=1, rconstraints = rconstraints, Nupper = Nupper)
ti
feasibility_theta <- function(theta_seq,alpha, R,rconstraints=NULL,Nupper=NULL){
results <- sapply(theta_seq, function(theta, alpha, R, rconstraints, Nupper){
#print(theta)
ri <- R * cos(theta)
rj <- R * sin(theta)
r <- c(ri, rj)
#we check first if the growth rates are within our constraints
if (!is.null(rconstraints)) {
r_good <- (r >= rconstraints$lower) & (r <= rconstraints$upper)
r_good <- prod(r_good)
} else{
r_good <- TRUE
}
#if they are not, we do not bother to solve for abundances
if (!r_good) {
#  segments(0,0,ri,rj, col="firebrick")
return(0)
} else{
# solve for the equilibrium given the interactions and the growth rate vector
N <- solve(alpha) %*% r
# check if N corresponds to feasibile equilibrium
N_feasible <- (N > 0) %>% prod()
#check if they are within our bounds of abundances
if (!is.null(Nupper)) {
N_good <- (N <= Nupper) %>% prod()
} else{
N_good <- TRUE
}
feasible <- prod(N_feasible * N_good)
# if(feasible){
#   segments(0,0,ri,rj, col="dodgerblue")
# }
return(feasible)
}
},alpha=alpha, R=R, rconstraints = rconstraints, Nupper=Nupper)
return(results)
}
#vectorized integration of theta
integrate_theta <-function( R_seq,alpha,rconstraints=NULL,Nupper=NULL ) {
thetas <- seq(0 , 2*pi, length.out = 1000)
results <- sapply(R_seq, function(R, alpha, rconstraints, Nupper){
area<- feasibility_theta(theta_seq = thetas,
alpha = alpha,
R = R,
rconstraints = rconstraints,
Nupper= Nupper)
# area<-integrate(f=feasibility_theta,
#                lower = 0,
#                upper = 2*pi,
#                alpha = alpha,
#                R = R,
#                rconstraints = rconstraints,
#                Nupper= Nupper)
#
print(area)
return(sum(area)/length(thetas))
}, alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
return(results)
}
ti<-integrate_radii(alpha = alpha, R=1, rconstraints = rconstraints, Nupper = Nupper)
ti
ti<-integrate_radii(alpha = alpha, R=10, rconstraints = rconstraints, Nupper = Nupper)
ti
integrate_theta <-function( R_seq,alpha,rconstraints=NULL,Nupper=NULL ) {
thetas <- seq(0 , 2*pi, length.out = 1000)
results <- sapply(R_seq, function(R, alpha, rconstraints, Nupper){
area<- feasibility_theta(theta_seq = thetas,
alpha = alpha,
R = R,
rconstraints = rconstraints,
Nupper= Nupper)
# area<-integrate(f=feasibility_theta,
#                lower = 0,
#                upper = 2*pi,
#                alpha = alpha,
#                R = R,
#                rconstraints = rconstraints,
#                Nupper= Nupper)
#
return(sum(area)/length(thetas))
}, alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
return(results)
}
integrate_radii <- function(alpha, R ,rconstraints=NULL,Nupper=NULL){
multiple_R <- integrate( f= integrate_theta,
lower = 0,
upper = R,
alpha = alpha,
rconstraints= rconstraints,
Nupper= Nupper)
return( multiple_R[1]$value/R)
#
# R_seq <- seq(0,R, length.out = 1000)
#
# multiple_R <- integrate_theta(R_seq = R_seq,
#                               alpha = alpha,
#                               rconstraints = rconstraints,
#                               Nupper = Nupper)
#
#
# return( sum(multiple_R)/length(R_seq))
}
ti<-integrate_radii(alpha = alpha, R=10, rconstraints = rconstraints, Nupper = Nupper)
ti
rconstraints <- list(
lower = c(-Inf, -Inf),
upper = c(1, Inf)
)
Nupper <- c(
i = Inf,
j = Inf
)
ti<-integrate_radii(alpha = alpha, R=10, rconstraints = rconstraints, Nupper = Nupper)
tt<-integrate_theta(R_seq = 1, alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
tt
alpha
rconstraints <- list(
lower = c(-Inf, -Inf),
upper = c(1, 1)
)
Nupper <- c(
i = Inf,
j = Inf
)
tt<-integrate_theta(R_seq = 1, alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
tt
tt<-integrate_theta(R_seq = 2, alpha = alpha, rconstraints = rconstraints, Nupper = Nupper)
tt
multiple_radii<- function(R, alpha, rconstraints=NULL, Nupper=NULL){
R_seq<- seq(0.000001,R,length.out = 100) %>% as.list()
values<- lapply(R_seq, function(x, alpha, rconstraints, Nupper){
saavedra <- Omega_SA(alpha)
theta_integration <- integrate_radii(alpha=alpha,
R=x,
rconstraints = rconstraints,
Nupper= Nupper)
results <- data.frame("R"=x, "Saavedras"=saavedra, "Theta"= theta_integration)
print(results)
return(results)
} ,alpha=alpha,
rconstraints = rconstraints,
Nupper = Nupper)
calcs <- do.call(rbind, values) %>% as.data.frame()
plot( calcs$R, calcs$Saavedras, pch=16, col="firebrick",
ylab= "Omega",
xlab= "Radius",
ylim = c(0,1))
points(calcs$R, calcs$Theta, pch=18, col="dodgerblue")
return(tt)
}
test_radii <- multiple_radii(R = 100,alpha = alpha,rconstraints = rconstraints,Nupper = Nupper)
test_radii <- multiple_radii(R = 100,alpha = alpha,rconstraints = rconstraints,Nupper = Nupper)
source("code/read_models.R")
getwd
getwd()
)
install.packages("ggpubr")
source("code/read_models.R")
getwd
getwd()
setwd("/home/albacervantes/")
ls
getwd()
setwd("/home/albacervantes/bayesian-competition/")
getwd()
source("code/read_models.R")
setwd("./model_objects")
setwd("/model_objects")
getwd
getwd()
setwd("./code")
getwd()
setwd("../")
getwd()
fixed_model<-function(model){
model_coef<-fixef(model)
coef<-as.matrix(model_coef[,1])
coef<-t(coef)
params<-as.data.frame(coef)
return(params)
}
get_fixed_growth<- function(model,
s,
g,
env){
params <- fixed_model(model)
lambda <- exp(params$lambda_Intercept)
lambda_env <- exp(params$lambda_Intercept + params$lambda_env)
a <- lambda*g
a_env <- lambda_env*g
b <- 1 - ((1-g)*s)
if("beta" %in% names(model$formula$pforms)) {
beta     <- exp(params$beta_Intercept)
beta_env <- exp(params$beta_Intercept + params$beta_env)
}else{
beta     <- NA
beta_env <- NA
}
#to calculate different growth rates based on the model we define growth based on the name of the model
if (model$name=="Beverton-Holt"){
growth <- (a/b) - 1
env_growth <- (a_env/b) - 1
}
if(model$name=="Lotka-Volterra"){
growth <- 1 - (b/a)
env_growth <- 1 - (b/a_env)
}
if(model$name =="Ricker"){
growth <- log(a/b)
env_growth <- log(a_env/b)
}
if(model$name=="Hassell"){
growth <- -1 + ((a/b)^(1/beta))
env_growth <-   -1 + ((a_env/b)^(1/beta_env))
}
if(env){
return(env_growth)
} else{
return(growth)
}
}
library(brms)
?posterior_samples
Nupper <- c(
i = Inf,
j = Inf
)
class(Nupper)
Nupper[i]
N<- c(2,3)
N
(N <= Nupper)
Nupper <- c(
i = 2,
j = 2
)
(N <= Nupper)
Nupper <- c(
i = 2,
j = 1
)
(N <= Nupper)
Nupper <- c(
i = 100,
j = 100
)
Nupper
alpha<-diag(2)
alpha
N
N <- c( 100,200)
r<-alpha %*% N
r
R<- sqrt(r[1]^2 + r[2]^2)
R
N
alpha
alpha[1,1]<-0.5
alpha
alpha[2,2]<-0.7
alpha
alpha
N
r<-alpha %*% N
r
N <- c( 100,100)
r<-alpha %*% N
r
?optim
alpha
N
r<-alpha %*% N
r
N
alpha[1,1]<-1
alpha[1,2]<-1
alpha[2,2]<-0
alpha[2,1]<-0
alpha
alpha[1,2]<-1
alpha[1,1]<-1
alpha[2,1]<-1
alpha
alpha[1,2]=0
alpha
N<-c(150,200)
r<-alpha %*% N
r
N<-c(150,300)
r<-alpha %*% N
r
