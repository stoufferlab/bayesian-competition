Nupper = Nupper,
R_max = R,
make_plot = make_plot)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=17)
abline (0,r[2]/r[1], lty=2 )
points(fixed_center[1], fixed_center[2], col="blue")
r
fixed_center <- r_feasible(
alpha = mean_alpha_matrix,
rconstraints = rconstraints,
Nupper = Nupper,
R_max = R,
make_plot = make_plot)
r <-c(7,2)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=10)
r <-c(7,3)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=10)
r <-c(5,3)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=10)
r <-c(5,4)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=10)
r <-c(5,5)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=10)
r <-c(5,6)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=10)
fixed_center <- r_feasible(
alpha = mean_alpha_matrix,
rconstraints = rconstraints,
Nupper = Nupper,
R_max = R,
make_plot = make_plot)
points(r[1]/10, r[2]/10, col="darkgoldenrod", pch=17)
abline(0, r[2]/r[1], lty=2)
points(fixed_center[1], fixed_center[2], col="blue")
points(fixed_centroid_SA[1], fixed_centroid_SA[2],col="red")
theta(r = fixed_center, r_c = fixed_centroid_SA)
r
rc
fixed_center
fixed_feasibility_SA
fixed_centroid_SA
theta(r_c=fixed_centroid_SA, r=r)
theta(r_c=fixed_center, r=r)
theta(r_c=fixed_center, r=fixed_centroid_SA)
theta(r_c=fixed_center, r=r)
r
theta(r_c=fixed_centroid_SA, r=r)
fixed_centroid_SA
class(fixed_centroid_SA)
r
a <- c( 0.4929508, 0.8434056)
a
b <- c()
fixed_center
b<-c(0.2343497, 0.4059345)
b
theta(r_c = a, r=r)
theta(r_c = b, r=r)
theta(r_c = a, r=b)
r
r <- r*10
r
theta(r_c = a, r=b)
theta(r_c = a, r=r)
calculate_distance(center = fixed_centroid_SA, r=)
r
r<- c(0.5,0.6)
calculate_distance(center = fixed_centroid_SA, r=r)
calculate_distance(center = fixed_center, r=r)
results_sunny <- readRDS("~/bayesian-competition/results_sunny.RDS")
head(results_sunny)
#iterating over models
library(brms)
library(ggplot2)
library(ggpubr)
library(tidyverse)
#We source everything known to human kind...
source("code/gg_theme.R")
source("code/read_models.R")
source("code/model_toolbox.R")
source("code/model_combo.R")
source("code/integration_toolbox.R")
source("code/model_toolbox.R")
source("code/determine_radius.R")
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
test <- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
Ni_max =1000,
sj = sj,
gj =gj,
Nj_max =  1000,
env = FALSE,
make_plot = TRUE )
posterior_feasibility <- function(vero_model,
trcy_model,
si,
gi,
Ni_max,
sj,
gj,
Nj_max,
env = FALSE,
make_plot = FALSE){
#for the mean omega and theta we get the  alpha matrix for mean parameter values
#for an environmental condition either 0 (control) or 1 (woody)
name <- paste0(vero_model$name, "and", trcy_model$name)
print(name)
mean_alpha_matrix <- get_fixed_alphas(
vero_model = vero_model,
trcy_model = trcy_model,
gi = gi,
gj = gj,
env = env)
#as well as r1 (vero's growth rate)
vero_growth <- get_fixed_growth(
model = vero_model,
s = si,
g = gi,
env = env)
#and r2 (trcy's growth rate)
trcy_growth <- get_fixed_growth(
model = trcy_model,
s = sj,
g = gj,
env = env)
#store them in a vector
r <- c(vero_growth,
trcy_growth)
# Each model has its own constraints
rconstraints <- list(
lower = c(vero_model$constraints[1], trcy_model$constraints[1]),
upper = c(vero_model$constraints[2], trcy_model$constraints[2])
)
#And each species its maximum expected abundances
Nupper <- c(i = Ni_max,
j = Nj_max)
#Which determine the Radius for each alpha matrix used
R <- determine_radius(alpha = mean_alpha_matrix,
Ni_max = Ni_max,
Nj_max = Nj_max)
# Knowing these we can calculate the feasibility domain and its center for mean parameter values
fixed_feasibility <- integrate_radii(
alpha = mean_alpha_matrix,
R = R,
rconstraints = rconstraints,
Nupper = Nupper)
#Saaveda et al. estimation
fixed_feasibility_SA <- Omega_SA(alpha = mean_alpha_matrix)
fixed_centroid_SA <- r_centroid(mean_alpha_matrix)
fixed_theta_SA <-theta(r_c = fixed_centroid_SA,
r =r)
# ou estimation of the center
fixed_center <- r_feasible(
alpha = mean_alpha_matrix,
rconstraints = rconstraints,
Nupper = Nupper,
R_max = R,
make_plot = make_plot)
#check if our growth rates are feasible
feasiblity_mean <- check_feasibility(
r = r,
alpha = mean_alpha_matrix,
rconstraints = rconstraints,
Nupper = Nupper )
#Calculate the distance from the center
distance_mean <- calculate_distance(center = fixed_center,
r = r)
theta_mean <- theta(r_c = fixed_center,
r = r )
#we store the values of coexistence using the point estimates
mean_parameters_results <- data.frame(
"Omega_mean_saaveda"= fixed_feasibility_SA,
"theta_mean_saavedra" = fixed_theta_SA,
"Omega_mean"= fixed_feasibility,
"distance_mean"=  distance_mean,
"theta_mean" = theta_mean,
"feasibility_mean"= feasiblity_mean,
"R_mean"=R)
print(mean_parameters_results)
#######NOW for the posterior parameters#################################
# we extract the posterior parameter values and growwth rates
vero_post <- posterior_parameters(model = vero_model,
s = si,
g = gi)
trcy_post <- posterior_parameters(model = trcy_model,
s = sj,
g = gj)
# we check if they are the same size
num_posterior<- identical(nrow(vero_post),nrow(trcy_post))
if(!num_posterior){
warning("Posterior distributions are not the same length")
}else{
print("working with the posterior distrubution")
#just to work with them, should comment out this part aftewards
vero_post<-vero_post[sample(nrow(vero_post), 10), ]
trcy_post<-trcy_post[sample(nrow(trcy_post), 10), ]
#to iterate over rows without using a loop
x <- seq(1,nrow(vero_post),1) %>% as.list()
posterior_parameters_results<-lapply(x,function(rows,gi,gj,rconstraints, Nupper){
alpha  <- alpha_matrix(
vero_row = vero_post[rows, ],
trcy_row = trcy_post[rows, ],
gi = gi,
gj = gj,
env = env )
if (env) {
r1 <- vero_post$env_growth[rows]
r2 <- trcy_post$env_growth[rows]
} else{
r1 <- vero_post$growth[rows]
r2 <- trcy_post$growth[rows]
}
r_post <- c(r1,r2)
#we determine R for every alpha matrix
R_post <- determine_radius(alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max)
omega_post <- integrate_radii(alpha = alpha,
R = R_post,
rconstraints = rconstraints,
Nupper = Nupper )
#Saavedras aproximation
omega_post_SA <- Omega_SA(alpha = alpha)
centroid_post_SA <- r_centroid(alpha=alpha)
theta_post_SA <- theta(r_c = centroid_post_SA,
r = r_post)
#center of the domain
center_post <- r_feasible(alpha = alpha,
rconstraints = rconstraints,
Nupper = Nupper,
R_max = R_post,
make_plot = FALSE)
#are our growth rates feasible?
feasibility_post <- check_feasibility(r= r_post,
alpha = alpha,
rconstraints = rconstraints,
Nupper = Nupper )
#how far away are they from the center
distance_post <- calculate_distance(center = center_post,
r = r_post)
theta_post <- theta(r_c = center_post,
r = r_post)
#all togethe
post_results <- data.frame(
"Omega_saaveda"= omega_post_SA,
"theta_saavedra"= theta_post_SA,
"Omega"= omega_post,
"distance"= distance_post,
"theta" = theta_post,
"feasibility" = feasibility_post,
"Radius" = R_post)
print(x)
return(post_results)
}, gi = gi,
gj = gj,
rconstraints = rconstraints,
Nupper = Nupper)
posterior_parameters_results <- do.call(rbind, posterior_parameters_results)
all_results <- cbind(mean_parameters_results, posterior_parameters_results)
all_results[,"vero_model"] <- vero_model$name
all_results[,"trcy_model"] <- trcy_model$name
# print(all_results)
file <- paste0(name,".RDS")
# print(file)
saveRDS(object = all_results,file = paste0(name,".RDS"))
return(all_results)
}
}
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
test <- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
Ni_max =1000,
sj = sj,
gj =gj,
Nj_max =  1000,
env = FALSE,
make_plot = TRUE )
ptm <- proc.time()
test <- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
Ni_max =1000,
sj = sj,
gj =gj,
Nj_max =  1000,
env = FALSE,
make_plot = TRUE )
proc.time() - ptm
TEST
test
1000*105
105000/60
1750/60
200*105
21000/60
350/60
400*105
105.699 / 1-
105.699 / 10
10 * 500
5000/60
source('~/bayesian-competition/code/model_toolbox.R')
posterior_feasibility <- function(vero_model,
trcy_model,
si,
gi,
Ni_max,
sj,
gj,
Nj_max,
env = FALSE,
make_plot = FALSE){
#for the mean omega and theta we get the  alpha matrix for mean parameter values
#for an environmental condition either 0 (control) or 1 (woody)
name <- paste0(vero_model$name, "and", trcy_model$name)
print(name)
mean_alpha_matrix <- get_fixed_alphas(
vero_model = vero_model,
trcy_model = trcy_model,
gi = gi,
gj = gj,
env = env)
#as well as r1 (vero's growth rate)
vero_growth <- get_fixed_growth(
model = vero_model,
s = si,
g = gi,
env = env)
#and r2 (trcy's growth rate)
trcy_growth <- get_fixed_growth(
model = trcy_model,
s = sj,
g = gj,
env = env)
#store them in a vector
r <- c(vero_growth,
trcy_growth)
# Each model has its own constraints
rconstraints <- list(
lower = c(vero_model$constraints[1], trcy_model$constraints[1]),
upper = c(vero_model$constraints[2], trcy_model$constraints[2])
)
#And each species its maximum expected abundances
Nupper <- c(i = Ni_max,
j = Nj_max)
#Which determine the Radius for each alpha matrix used
R <- determine_radius(alpha = mean_alpha_matrix,
Ni_max = Ni_max,
Nj_max = Nj_max)
# Knowing these we can calculate the feasibility domain and its center for mean parameter values
fixed_feasibility <- integrate_radii(
alpha = mean_alpha_matrix,
R = R,
rconstraints = rconstraints,
Nupper = Nupper)
#Saaveda et al. estimation
fixed_feasibility_SA <- Omega_SA(alpha = mean_alpha_matrix)
fixed_centroid_SA <- r_centroid(mean_alpha_matrix)
fixed_theta_SA <-theta(r_c = fixed_centroid_SA,
r =r)
# ou estimation of the center
fixed_center <- r_feasible(
alpha = mean_alpha_matrix,
rconstraints = rconstraints,
Nupper = Nupper,
R_max = R,
make_plot = make_plot)
#check if our growth rates are feasible
feasiblity_mean <- check_feasibility(
r = r,
alpha = mean_alpha_matrix,
rconstraints = rconstraints,
Nupper = Nupper )
#Calculate the distance from the center
distance_mean <- calculate_distance(center = fixed_center,
r = r)
theta_mean <- theta(r_c = fixed_center,
r = r )
#we store the values of coexistence using the point estimates
mean_parameters_results <- data.frame(
"Omega_mean_saaveda"= fixed_feasibility_SA,
"theta_mean_saavedra" = fixed_theta_SA,
"Omega_mean"= fixed_feasibility,
"distance_mean"=  distance_mean,
"theta_mean" = theta_mean,
"feasibility_mean"= feasiblity_mean,
"R_mean"=R)
print(mean_parameters_results)
#######NOW for the posterior parameters#################################
# we extract the posterior parameter values and growwth rates
vero_post <- posterior_parameters(model = vero_model,
s = si,
g = gi)
trcy_post <- posterior_parameters(model = trcy_model,
s = sj,
g = gj)
# we check if they are the same size
num_posterior<- identical(nrow(vero_post),nrow(trcy_post))
if(!num_posterior){
warning("Posterior distributions are not the same length")
}else{
print("working with the posterior distrubution")
#just to work with them, should comment out this part aftewards
vero_post<-vero_post[sample(nrow(vero_post), 1000), ]
trcy_post<-trcy_post[sample(nrow(trcy_post), 1000), ]
#to iterate over rows without using a loop
x <- seq(1,nrow(vero_post),1) %>% as.list()
posterior_parameters_results<-lapply(x,function(rows,gi,gj,rconstraints, Nupper){
alpha  <- alpha_matrix(
vero_row = vero_post[rows, ],
trcy_row = trcy_post[rows, ],
gi = gi,
gj = gj,
env = env )
if (env) {
r1 <- vero_post$env_growth[rows]
r2 <- trcy_post$env_growth[rows]
} else{
r1 <- vero_post$growth[rows]
r2 <- trcy_post$growth[rows]
}
r_post <- c(r1,r2)
#we determine R for every alpha matrix
R_post <- determine_radius(alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max)
omega_post <- integrate_radii(alpha = alpha,
R = R_post,
rconstraints = rconstraints,
Nupper = Nupper )
#Saavedras aproximation
omega_post_SA <- Omega_SA(alpha = alpha)
centroid_post_SA <- r_centroid(alpha=alpha)
theta_post_SA <- theta(r_c = centroid_post_SA,
r = r_post)
#center of the domain
center_post <- r_feasible(alpha = alpha,
rconstraints = rconstraints,
Nupper = Nupper,
R_max = R_post,
make_plot = FALSE)
#are our growth rates feasible?
feasibility_post <- check_feasibility(r= r_post,
alpha = alpha,
rconstraints = rconstraints,
Nupper = Nupper )
#how far away are they from the center
distance_post <- calculate_distance(center = center_post,
r = r_post)
theta_post <- theta(r_c = center_post,
r = r_post)
#all togethe
post_results <- data.frame(
"Omega_saaveda"= omega_post_SA,
"theta_saavedra"= theta_post_SA,
"Omega"= omega_post,
"distance"= distance_post,
"theta" = theta_post,
"feasibility" = feasibility_post,
"Radius" = R_post)
print(x)
return(post_results)
}, gi = gi,
gj = gj,
rconstraints = rconstraints,
Nupper = Nupper)
posterior_parameters_results <- do.call(rbind, posterior_parameters_results)
all_results <- cbind(mean_parameters_results, posterior_parameters_results)
all_results[,"vero_model"] <- vero_model$name
all_results[,"trcy_model"] <- trcy_model$name
# print(all_results)
file <- paste0(name,".RDS")
# print(file)
saveRDS(object = all_results,file = paste0(name,".RDS"))
return(all_results)
}
}
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test <- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
Ni_max =1000,
sj = sj,
gj =gj,
Nj_max =  1000,
env = FALSE,
make_plot = TRUE )
proc.time() - ptm
install.packages("staplr")
