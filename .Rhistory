plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
abline(0,upper)
abline(0,lower)
x1<-c(upper*1,lower*1)
x1
x2<-c(upper*10,lower*10)
plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
arrows(0,0,x1[1],x1[2])
x1<-c(upper*1,upper*10)
x2<-c(lower*1,lower*10)
plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
arrows(0,0,x1[1],x1[2])
arrows(0,0,x2[1],x2[2])
x2<-c(lower*1,lower*10)
lower
upper
plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
arrows(0,0,x1[1],x1[2])
arrows(0,0,x2[1],x2[2])
x1
x2
plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
arrows(0,0,x1[1],x2[2])
arrows(0,0,x1[1],x1[2])
plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
arrows(0,0,x1[1],x1[2])
abline(0,upper,col=2)
abline(0,lower)
plot(1,type="n",xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
upper<-alpha22/alpha12
lower<-alpha21/alpha11
omega<-Omega(alpha)
abline(0,lower)
abline(0,upper)
alpha
D <- diag(1/sqrt(diag(t(alpha)%*%alpha)))
alpha_n <- alpha %*% D
alpha
vc <- (v1 + v2 )
vc <- vc / sqrt(sum(vc^2))
?scatterplot3d
require('scatterplot3d')
require('pracma')
install.packages("pracma")
alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
Omega_saa(alpha)
Omega_two(alpha)
Omega_song(alpha)
Omega_song_two(alpha)
#######figuring out how to work with saavedras code
require(mvtnorm)
Omega_saa <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega_two<-function(alpha){
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
num<- (alpha11*alpha22) - (alpha12*alpha21)
denom<- (sqrt( (alpha11)^2 + (alpha12)^2))*(sqrt( (alpha12)^2 + (alpha22)^2))
a<- num/denom
my_omega<-(2/pi)* (asin(a))
return(my_omega)
}
Omega_song<-function(alpha){
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
Q1<-alpha21/alpha11
Q2<- alpha12/alpha22
y<- (sqrt( 1 + (Q1)^2)) * (sqrt( 1 + (Q2)^2))
x<- (Q1+Q2)/( y)
song_omega<- acos(x)
return(song_omega)
}
Omega_song_two <- function(alpha) {
S <- nrow(alpha)
omega <- function(S, Sigma) {
m <- matrix(0, S, 1)
a <- matrix(0, S, 1)
b <- matrix(Inf, S, 1)
d <- pmvnorm(lower = rep(0, S), upper = rep(Inf, S), mean = rep(0, S), sigma = Sigma)
out <- d[1]^(1 / S)
return(out)
}
#   if (length(which(diag(alpha) == 0)) == 0) {
#     Sigma <- chol2inv(alpha, size = NCOL(alpha), LINPACK = FALSE)
#     return(omega(S, Sigma))
#   }
#   else {
f <- function(m) class(try(solve(t(m) %*% m), silent = T)) == "matrix"
if (f(alpha) == FALSE) {
return(0)
}
else {
Sigma <- solve(t(alpha) %*% alpha)
return(omega(S, Sigma))
}
#   }
# }
}
# alpha_one <- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
# alpha_two<-matrix(c(1,.4,.5,.9), nrow=2, ncol=2,byrow = TRUE)
alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
Omega_saa(alpha)
Omega_two(alpha)
Omega_song(alpha)
Omega_song_two(alpha)
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
aalpha
alpha
Omega_saa(alpha)
Omega_two(alpha)
Omega_song_two(alpha)
log10(0.3400716)
log10(0.3400716)+ 2*log10(2)
Omega_two(alpha)
Omega_saa <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
# alpha_two<-matrix(c(1,.4,.5,.9), nrow=2, ncol=2,byrow = TRUE)
#alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
Omega_saa(alpha)
Omega_two(alpha)
Omega_two(alpha)
Omega_saa <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega_saa(alpha)
Omega_two(alpha)
Omega_song_two(alpha)
rm(list=ls())
source('code/toolbox_coexistence.R')
source('code/toolbox_figure.R')
r <- c(1,1,0.5)
Omega(alpha)
alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
Omega(alpha)
r_c <- r_centroid(alpha)
r_c
test_feasibility_pairs(alpha,r)
compute_overlap(alpha,10000)
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
alpha
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
alpha
Omega(alpha)
compute_overlap(alpha,10000)
Omega_two<-function(alpha){
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
num<- (alpha11*alpha22) - (alpha12*alpha21)
denom<- (sqrt( (alpha11)^2 + (alpha12)^2))*(sqrt( (alpha12)^2 + (alpha22)^2))
a<- num/denom
my_omega<-(2/pi)* (asin(a))
return(my_omega)
}
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
# alpha_two<-matrix(c(1,.4,.5,.9), nrow=2, ncol=2,byrow = TRUE)
#alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
Omega_saa(alpha)
Omega_two(alpha)
Omega_saa <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
Omega_saa(alpha)
Omega_saa <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
Omega_two(alpha)
Omega_saa(alpha)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
Omega(alpha)
Omega_saa <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
Omega_saa(alpha)
Omega_two<-function(alpha){
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
num<- (alpha11*alpha22) - (alpha12*alpha21)
denom<- (sqrt( (alpha11)^2 + (alpha12)^2))*(sqrt( (alpha12)^2 + (alpha22)^2))
a<- num/denom
my_omega<-(2/pi)* (asin(a))
return(my_omega)
}
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d)
}
Omega(alpha)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega(alpha)
Omega_two(alpha)
compute_overlap(alpha,10000)
compute_overlap <- function(alpha,Nrand){
n <- dim(alpha)[1]
counter_f <- 0
counter_overlap <- 0
counter_all <- 0
for (i in 1:Nrand){
r_rand <- abs(rnorm(n))
r_rand <- r_rand/sqrt(sum(r_rand^2))
f1 <- test_feasibility(alpha,r_rand)
f2 <- test_feasibility_pairs(alpha,r_rand)$feasibility
counter_f <- counter_f + f1
counter_all <- counter_all + prod(f2)
counter_overlap <- counter_overlap + f1*prod(f2)
}
Omega <- counter_f/Nrand
Omega_all <- counter_all/Nrand
overlap <- counter_overlap/Nrand
out <- list(Omega = Omega, Omega_all = Omega_all, overlap = overlap)
return(out)
}
compute_overlap(alpha)
compute_overlap(alpha,10000)
rm(list=ls())
source('code/toolbox_coexistence.R')
source('code/toolbox_figure.R')
#3-species interaction matrix of figure 5 and 6
alpha <- matrix(c(1,0.5,0.05,0.4,1,0.5,0.3,0.6,1),3,3)
alpha<- matrix(c(1,0.5,0.4,1),nrow=2,ncol=2)
install.packages("scatterplot3d")
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega(alpha)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
Omega(alpha)
Omega_two<-function(alpha){
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
num<- (alpha11*alpha22) - (alpha12*alpha21)
denom<- (sqrt( (alpha11)^2 + (alpha12)^2))*(sqrt( (alpha12)^2 + (alpha22)^2))
a<- num/denom
my_omega<-(2/pi)* (asin(a))
return(my_omega)
}
Omega_two(alpha)
Omega_song_two <- function(alpha) {
S <- nrow(alpha)
omega <- function(S, Sigma) {
m <- matrix(0, S, 1)
a <- matrix(0, S, 1)
b <- matrix(Inf, S, 1)
d <- pmvnorm(lower = rep(0, S), upper = rep(Inf, S), mean = rep(0, S), sigma = Sigma)
out <- d[1]^(1 / S)
return(out)
}
#   if (length(which(diag(alpha) == 0)) == 0) {
#     Sigma <- chol2inv(alpha, size = NCOL(alpha), LINPACK = FALSE)
#     return(omega(S, Sigma))
#   }
#   else {
f <- function(m) class(try(solve(t(m) %*% m), silent = T)) == "matrix"
if (f(alpha) == FALSE) {
return(0)
}
else {
Sigma <- solve(t(alpha) %*% alpha)
return(omega(S, Sigma))
}
#   }
# }
}
Omega_song_two(alpha)
alpha<-matrix(c(1,.5,.4,1),ncol+2, nrow = 2)
alpha<-matrix(c(1,.5,.4,1),ncol=2, nrow = 2)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega(alpha)
require(mvtnorm)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega(alpha)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
Omega(alpha)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d1)
}
log10(d1)
Omega(alpha)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(d[1])
}
Omega(alpha)
o<-Omega(alpha)
log10(o)
log10(o) + 2*log10(2)
Omega_two<-function(alpha){
alpha11<-alpha[1,1]
alpha12<-alpha[1,2]
alpha21<-alpha[2,1]
alpha22<-alpha[2,2]
num<- (alpha11*alpha22) - (alpha12*alpha21)
denom<- (sqrt( (alpha11)^2 + (alpha12)^2))*(sqrt( (alpha12)^2 + (alpha22)^2))
a<- num/denom
my_omega<-(2/pi)* (asin(a))
return(my_omega)
}
a<-Omega_two(alpha)
a
log10(a)
o
log10(a)
log10(a) + 2+log10(2)
#structural niche difference (output on a log scale)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
source('code/toolbox_coexistence.R')
source('code/toolbox_figure.R')
#structural niche difference (Omega)
Omega(alpha)
#centroid of the feasibility domain
r_c <- r_centroid(alpha)
r_c
r<-c(1,1)
theta(alpha,r)
test_feasibility(alpha,r)
test_feasibility_pairs(alpha,r)
bility domain and the domain of coexistence of all the pairs (with 10000 randomizations)
compute_overlap(alpha,10000)
Omega_two(alpha)
untrace()
untrace(omega)
untrace(Omega)
untrace(f)
f <- function(m) class(try(solve(t(m) %*% m), silent = T)) == "matrix"
if (f(alpha) == FALSE) {
return(0)
}
else {
Sigma <- solve(t(alpha) %*% alpha)
return(omega(S, Sigma))
}
#   }
# }
}
Omega <- function(alpha) {
S <- nrow(alpha)
omega <- function(S, Sigma) {
m <- matrix(0, S, 1)
a <- matrix(0, S, 1)
b <- matrix(Inf, S, 1)
d <- pmvnorm(lower = rep(0, S), upper = rep(Inf, S), mean = rep(0, S), sigma = Sigma)
out <- d[1]^(1 / S)
return(out)
}
#   if (length(which(diag(alpha) == 0)) == 0) {
#     Sigma <- chol2inv(alpha, size = NCOL(alpha), LINPACK = FALSE)
#     return(omega(S, Sigma))
#   }
#   else {
f <- function(m) class(try(solve(t(m) %*% m), silent = T)) == "matrix"
if (f(alpha) == FALSE) {
return(0)
}
else {
Sigma <- solve(t(alpha) %*% alpha)
return(omega(S, Sigma))
}
#   }
# }
}
Omega_song <- function(alpha) {
S <- nrow(alpha)
omega <- function(S, Sigma) {
m <- matrix(0, S, 1)
a <- matrix(0, S, 1)
b <- matrix(Inf, S, 1)
d <- pmvnorm(lower = rep(0, S), upper = rep(Inf, S), mean = rep(0, S), sigma = Sigma)
out <- d[1]^(1 / S)
return(out)
}
#   if (length(which(diag(alpha) == 0)) == 0) {
#     Sigma <- chol2inv(alpha, size = NCOL(alpha), LINPACK = FALSE)
#     return(omega(S, Sigma))
#   }
#   else {
f <- function(m) class(try(solve(t(m) %*% m), silent = T)) == "matrix"
if (f(alpha) == FALSE) {
return(0)
}
else {
Sigma <- solve(t(alpha) %*% alpha)
return(omega(S, Sigma))
}
#   }
# }
}
alpha<-matrix(c(1,.5,.4,1),ncol=2, nrow = 2)
Omega_song(alpha)
Omega_two(alpha)
Omega(alpha)
Omega()
Omega
rm(Omega)
Omega <- function(alpha){
n <- nrow(alpha)
Sigma <-solve(t(alpha) %*% alpha)
d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
out <- log10(d[1]) + n * log10(2)
return(out)
}
Omega(alpha)
alpha<-matrix(c(.5,1,1,.5),ncol=2, nrow = 2)
alpha
Omega_song(alpha)
alpha<-matrix(c(.05,1,1,.05),ncol=2, nrow = 2)
Omega_song(alpha)
alpha<-matrix(c(.05,1,1,.05),ncol=2, nrow = 2)
Omega_song(alpha)
alpha
Omega_two(alpha)
Omega(alpha)
