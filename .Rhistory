center <- poi(x = shape$ri,
y = shape$rj)
#we get the shortest distance from the center of the polygon to an edge, it is always feasible
center_distance <- shortest_distance(r= c(center$x, center$y),
shape = shape,
feasibility = 1)
#we get the shortest distance from our growth rates to an edge
growth_distance <- shortest_distance(r = r,
shape = shape,
feasibility = feasibility)
results <- data.frame("center_distance" =center_distance,
"growth_distance"= growth_distance)
return(results)
}
feasibility <- feasiblity_mean
if(nn==0 | lines_in_shape < 2){
distance <- calculate_distance( p1 =  r,
p2 = c(0,0))
distance <- distance*feas
results <- data.frame("center_distance" = distance,
"growth_distance"= 0)
return(results)
}else{
#if the feasibility domain is only a line, and not a volume, then we can not detect the minimum distance to a boundary
#the center of the polygon
center <- poi(x = shape$ri,
y = shape$rj)
#we get the shortest distance from the center of the polygon to an edge, it is always feasible
center_distance <- shortest_distance(r= c(center$x, center$y),
shape = shape,
feasibility = 1)
#we get the shortest distance from our growth rates to an edge
growth_distance <- shortest_distance(r = r,
shape = shape,
feasibility = feasibility)
results <- data.frame("center_distance" =center_distance,
"growth_distance"= growth_distance)
return(results)
}
if(nn==0 | lines_in_shape < 2){
print(1)
distance <- calculate_distance( p1 =  r,
p2 = c(0,0))
distance <- distance*feas
results <- data.frame("center_distance" = distance,
"growth_distance"= 0)
#return(results)
}else{
#if the feasibility domain is only a line, and not a volume, then we can not detect the minimum distance to a boundary
#the center of the polygon
center <- poi(x = shape$ri,
y = shape$rj)
#we get the shortest distance from the center of the polygon to an edge, it is always feasible
center_distance <- shortest_distance(r= c(center$x, center$y),
shape = shape,
feasibility = 1)
#we get the shortest distance from our growth rates to an edge
growth_distance <- shortest_distance(r = r,
shape = shape,
feasibility = feasibility)
results <- data.frame("center_distance" =center_distance,
"growth_distance"= growth_distance)
# return(results)
}
center
center_distance <- shortest_distance(r= c(center$x, center$y),
shape = shape,
feasibility = 1)
center_distance
results
growth_distance <- shortest_distance(r = r,
shape = shape,
feasibility = feasibility)
gowth_distance
growth_distance
shape
r
alpha_mean
env <- TRUE
alpha_mean <- get_fixed_alphas(
vero_model = vero_model,
trcy_model = trcy_model,
gi = gi,
gj = gj,
env = env)
alpha <- alpha_mean
feasibility
feas <- ifelse(feasibility,1,-1)
shape <- determine_feasibility_shape(alpha = alpha,
R_max = R_max,
rconstraints = rconstraints,
Nupper = Nupper)
shape
plot(shape$ri, shape$rj)
plot(shape$ri, shape$rj, type= "l")
N <- nrow(shape) -1
data_dist <- c()
cc <- c()
#for every line defined by two points, we calculate the distance of our growth rates to it
for(i in 1:N) {
# points that define the line
p0 <- c(shape[i, ]$ri, shape[i, ]$rj)
p1 <- c(shape[i + 1, ]$ri, shape[i + 1, ]$rj)
#we make everything a matrix
line_matrix <- rbind(p0, p1) %>% as.matrix()
r <- as.matrix(r) %>% t
#we get the shortest distance from the point to the line, which is the distance between the point and the perpendicula projections of the line
dist <- SpatialGraph::pointLineD(xy = line_matrix,
xyp = r)
# does the perpendicular projection of the points crosses the segment or not
cross <- dist$cross
#if it does not, then the shortest distance is the distance to one of the edges of the line
if (cross == 0) {
dist_p0 <- calculate_distance(p1 = p0,
p2 = r)
dist_p1 <- calculate_distance(p1 = p1,
p2 = r)
dist_m <-  ifelse(dist_p0 > dist_p1,
dist_p1,
dist_p0)
type <- "point"
} else{
#if it does, then the shortest distance is to the perpendicular projection of the line
dist_m <- dist$d
type <- "line"
}
data <- data.frame(
"distance_from_edge" = dist_m,
#"distance_point1"= dist_pt1,
#"distance_point2"= dist_pt2,
"p1x" = p0[1],
"p1y" = p0[2],
"p2x" = p1[1],
"p2y" = p1[2],
"type"= type
)
data_dist <- rbind(data_dist, data)
}
#and we return which distance is the shortest
minimum_distance <- data_dist[which(data_dist$distance_from_edge == min(data_dist$distance_from_edge)), ]
#
minimum_distance
N <- nrow(shape) -1
data_dist <- c()
cc <- c()
#for every line defined by two points, we calculate the distance of our growth rates to it
for(i in 1:N) {
# points that define the line
p0 <- c(shape[i, ]$ri, shape[i, ]$rj)
p1 <- c(shape[i + 1, ]$ri, shape[i + 1, ]$rj)
print(i)
#we make everything a matrix
line_matrix <- rbind(p0, p1) %>% as.matrix()
r <- as.matrix(r) %>% t
#we get the shortest distance from the point to the line, which is the distance between the point and the perpendicula projections of the line
dist <- SpatialGraph::pointLineD(xy = line_matrix,
xyp = r)
# does the perpendicular projection of the points crosses the segment or not
cross <- dist$cross
#if it does not, then the shortest distance is the distance to one of the edges of the line
if (cross == 0) {
dist_p0 <- calculate_distance(p1 = p0,
p2 = r)
dist_p1 <- calculate_distance(p1 = p1,
p2 = r)
dist_m <-  ifelse(dist_p0 > dist_p1,
dist_p1,
dist_p0)
type <- "point"
} else{
#if it does, then the shortest distance is to the perpendicular projection of the line
dist_m <- dist$d
type <- "line"
}
data <- data.frame(
"distance_from_edge" = dist_m,
#"distance_point1"= dist_pt1,
#"distance_point2"= dist_pt2,
"p1x" = p0[1],
"p1y" = p0[2],
"p2x" = p1[1],
"p2y" = p1[2],
"type"= type
)
data_dist <- rbind(data_dist, data)
}
data_dist
minimum_distance <- data_dist[which(data_dist$distance_from_edge == min(data_dist$distance_from_edge)), ]
minimum_distance
minimum_distance <- unique(minimum_distance$distance_from_edge)
minimum_distance
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/model_toolbox.R")
source("code/determine_radius.R")
source("code/determine_boundary.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_lv_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = 1e3,
Nj_max = 1e3,
env = TRUE,
bounded = TRUE)
proc.time() - ptm
test_2
test_2<- posterior_feasibility(vero_model = vero_lv_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = 1e3,
Nj_max = 1e3,
env = TRUE,
bounded = FALSE)
proc.time() - ptm
test_2
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_lv_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = 1e4,
Nj_max = 1e4,
env = TRUE,
bounded = FALSE)
proc.time() - ptm
test_2
library(brms)
library(ggplot2)
library(ggpubr)
library(tidyverse)
#We source everything known to human kind...
source("code/read_models.R")
source("code/model_toolbox.R")
source("code/model_combo.R")
source("code/integration_toolbox.R")
source("code/model_toolbox.R")
source("code/determine_radius.R")
source("code/determine_boundary.R")
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
# the list of models over to iterate
vero_models <- list( vero_bh_multispecies_poisson.rds,
vero_lv_multispecies_poisson.rds,
vero_rc_multispecies_poisson.rds)
trcy_models<- list(trcy_bh_multispecies_poisson.rds,
trcy_lv_multispecies_poisson.rds,
trcy_rc_multispecies_poisson.rds)
model_grid_sunny<- combined_models(vero_models = vero_models,
trcy_models = trcy_models,
si =si,
gi =gi,
gj =gj,
sj=sj,
Ni_max = 1e4,
Nj_max =1e4,
env=FALSE,
bounded = TRUE)
saveRDS(model_grid_sunny,
file = "results.RDS")
# model_grid_woody<- combined_models(vero_models = vero_models,
#                                    trcy_models = trcy_models,
#                                    si =si,
#                                    gi =gi,
#                                    gj =gj,
#                                    sj=sj,
#                                    Ni = 1e4,
#                                    Nj =1e4,
#                                    env=TRUE,
#                                    make_plot = FALSE)
# saveRDS(model_grid_woody,
#         file = "results_woody_25jan21.RDS")
#
vero_models
trcy_model <- trcy_models[[1]]
fixed_row_model(vero_models = vero_models, trcy_model = trcy_model,si = si,gi = gi,Ni_max = 1e4,sj = sj,gj = gj,Nj_max = e4,env = FALSE,bounded = TRUE)
posterior_feasibility(vero_model = vero_models[[1]], trcy_model = trcy_model,si = si,gi = gi,Ni_max = 1e4,sj = sj,gj = gj,Nj_max = 1e4,env = FALSE,bounded = TRUE)
fixed_row_model <- function(vero_models,
trcy_model,
si,
gi,
Ni_max,
sj,
gj,
Nj_max,
env = FALSE,
bounded = TRUE){
one_row<-lapply(vero_models,function(m){
post <- posterior_feasibility(vero_model=m,
trcy_model = trcy_model,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = Ni_max,
Nj_max = Nj_max,
env = env,
bounded = bounded)
return(post)
},  trcy_model = trcy_model,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = Ni,
Nj_max = Nj,
env = env,
bounded = bounded )
all_posteriors <- do.call(rbind, one_row)
return(all_posteriors)
}
fixed_row_model(vero_models = vero_models, trcy_model = trcy_model,si = si,gi = gi,Ni_max = 1e4,sj = sj,gj = gj,Nj_max = e4,env = FALSE,bounded = TRUE)
fixed_row_model <- function(vero_models,
trcy_model,
si,
gi,
Ni_max,
sj,
gj,
Nj_max,
env = FALSE,
bounded = TRUE){
one_row<-lapply(vero_models,function(m){
post <- posterior_feasibility(vero_model=m,
trcy_model = trcy_model,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = Ni_max,
Nj_max = Nj_max,
env = env,
bounded = bounded)
return(post)
},  trcy_model = trcy_model,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = Ni_max,
Nj_max = Nj_max,
env = env,
bounded = bounded )
all_posteriors <- do.call(rbind, one_row)
return(all_posteriors)
}
fixed_row_model(vero_models = vero_models, trcy_model = trcy_model,si = si,gi = gi,Ni_max = 1e4,sj = sj,gj = gj,Nj_max = e4,env = FALSE,bounded = TRUE)
fixed_row_model(vero_models = vero_models, trcy_model = trcy_model,si = si,gi = gi,Ni_max = 1e4,sj = sj,gj = gj,Nj_max = 1e4,env = FALSE,bounded = TRUE)
fixed_row_model <- function(vero_models,
trcy_model,
si,
gi,
Ni_max,
sj,
gj,
Nj_max,
env = FALSE,
bounded = TRUE){
one_row<-lapply(vero_models,function(m,
trcy_model,
si,
gi,
sj,
gj,
Ni_max,
Nj_max,
env,
bounded){
post <- posterior_feasibility(vero_model=m,
trcy_model = trcy_model,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = Ni_max,
Nj_max = Nj_max,
env = env,
bounded = bounded)
return(post)
},  trcy_model = trcy_model,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = Ni_max,
Nj_max = Nj_max,
env = env,
bounded = bounded )
all_posteriors <- do.call(rbind, one_row)
return(all_posteriors)
}
fixed_row_model(vero_models = vero_models, trcy_model = trcy_model,si = si,gi = gi,Ni_max = 1e4,sj = sj,gj = gj,Nj_max = 1e4,env = FALSE,bounded = TRUE)
#iterating over models
library(brms)
library(ggplot2)
library(ggpubr)
library(tidyverse)
#We source everything known to human kind...
source("code/read_models.R")
source("code/model_toolbox.R")
source("code/model_combo.R")
source("code/integration_toolbox.R")
source("code/model_toolbox.R")
source("code/determine_radius.R")
source("code/determine_boundary.R")
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
# the list of models over to iterate
vero_models <- list( vero_bh_multispecies_poisson.rds,
vero_lv_multispecies_poisson.rds,
vero_rc_multispecies_poisson.rds)
trcy_models<- list(trcy_bh_multispecies_poisson.rds,
trcy_lv_multispecies_poisson.rds,
trcy_rc_multispecies_poisson.rds)
model_grid_sunny<- combined_models(vero_models = vero_models,
trcy_models = trcy_models,
si =si,
gi =gi,
gj =gj,
sj=sj,
Ni_max = 1e4,
Nj_max =1e4,
env=FALSE,
bounded = TRUE)
saveRDS(model_grid_sunny,
file = "results.RDS")
rconstraints <- list(
lower = c(-Inf, -Inf),
upper = c(Inf, Inf)
)
rconstraints
rconstraints$lower
rconstraints$lower[1]
x_min <- ifelse(rconstraints$lower[1] == -Inf, -R_mean, rconstraints$lower[1])
R_mean <- 67
x_min <- ifelse(rconstraints$lower[1] == -Inf, -R_mean, rconstraints$lower[1])
x_min
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/model_toolbox.R")
source("code/determine_radius.R")
source("code/determine_boundary.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_lv_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni_max  = 1e4,
Nj_max = 1e4,
env = TRUE,
bounded = FALSE)
proc.time() - ptm
#iterating over models
library(brms)
library(ggplot2)
library(ggpubr)
library(tidyverse)
#We source everything known to human kind...
source("code/read_models.R")
source("code/model_toolbox.R")
source("code/model_combo.R")
source("code/integration_toolbox.R")
source("code/model_toolbox.R")
source("code/determine_radius.R")
source("code/determine_boundary.R")
#survival and germination for Vero (i) and Trcy(j)
gi<-.372
si<-.556
gj<-.258
sj<-.033
# the list of models over to iterate
vero_models <- list( vero_bh_multispecies_poisson.rds,
vero_lv_multispecies_poisson.rds,
vero_rc_multispecies_poisson.rds)
trcy_models<- list(trcy_bh_multispecies_poisson.rds,
trcy_lv_multispecies_poisson.rds,
trcy_rc_multispecies_poisson.rds)
model_grid_sunny<- combined_models(vero_models = vero_models,
trcy_models = trcy_models,
si =si,
gi =gi,
gj =gj,
sj=sj,
Ni_max = 1e4,
Nj_max =1e4,
env=FALSE,
bounded = TRUE)
saveRDS(model_grid_sunny,
file = "results.RDS")
