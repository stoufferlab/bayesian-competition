ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max,
)
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
# And look at the values of Ni and Nj that give that R
solution$pars
R
require(Rsolnp)
#to maximize f(x) is equivalent to minimizing -f(x)
# so this is a function that gives you -R^2
radius<- function(N, alpha, Ni_max, Nj_max){
#Where N[1] is Ni and N[2] is Nj
r1 = ( (N[1]*alpha[1,1]) + (N[2]*alpha[1,2]))^2
r2 = ( (N[1]*alpha[1,2]) + (N[2]*alpha[2,2]))^2
# remember that this actually gives you -f(x)
R = - r1 - r2
return(R)
}
# The inequality constraints have to have a lower and uper bound :
#  - Ni_max <= Ni - Ni_max <= 0
#Note that the main and constraint functions must take the exact same arguments, irrespective of whether they are used by all of them.
inequalities <- function(N,alpha, Ni_max, Nj_max) {
z1=  N[1] - Ni_max
z2=  N[2] - Nj_max
return(c(z1, z2))
}
# Ni/Nj has to be equal or smaller than Ni_max
upper_constraints <- c(0,0)
# Ni/Nj has to be equal or greater than 0
lower_constraints <- c(-Ni_max,-Nj_max)
#random interaxion matrix
alpha <- matrix(runif(4, -1,.5), ncol = 2, nrow = 2)
#arbitrary maximum abundances
Ni_max <- 200
Nj_max <- 800
#starting params in the middle rather than boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max,
)
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
# And look at the values of Ni and Nj that give that R
solution$pars
R
#random interaxion matrix
alpha <- matrix(runif(4, -1,.5), ncol = 2, nrow = 2)
#arbitrary maximum abundances
Ni_max <- 500
Nj_max <- 800
#starting params in the middle rather than boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max,
)
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
# And look at the values of Ni and Nj that give that R
solution$pars
R
alpha <- matrix(runif(4, -1,.5), ncol = 2, nrow = 2)
#arbitrary maximum abundances
Ni_max <- 300
Nj_max <- 800
#starting params in the middle rather than boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max,
)
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
# And look at the values of Ni and Nj that give that R
solution$pars
alpha <- matrix(runif(4, -1,.5), ncol = 2, nrow = 2)
#arbitrary maximum abundances
Ni_max <- 300
Nj_max <- 800
#starting params in the middle rather than boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max,
)
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
# And look at the values of Ni and Nj that give that R
solution$pars
R
require(Rsolnp)
#to maximize f(x) is equivalent to minimizing -f(x)
# so this is a function that gives you -R^2
radius<- function(N, alpha, Ni_max, Nj_max){
#Where N[1] is Ni and N[2] is Nj
r1 = ( (N[1]*alpha[1,1]) + (N[2]*alpha[1,2]))^2
r2 = ( (N[1]*alpha[1,2]) + (N[2]*alpha[2,2]))^2
# remember that this actually gives you -f(x)
R = - r1 - r2
return(R)
}
#Note that the main and constraint functions must take the exact same arguments, irrespective of whether they are used by all of them.
inequalities <- function(N,alpha, Ni_max, Nj_max) {
z1=  N[1] - Ni_max
z2=  N[2] - Nj_max
return(c(z1, z2))
}
determine_radius<- function(alpha, Ni_max, Nj_max){
# Ni/Nj has to be equal or smaller than Ni_max
upper_constraints <- c(0,0)
# Ni/Nj has to be equal or greater than 0
lower_constraints <- c(-Ni_max,-Nj_max)
#initial params at the center not at the boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max)
convergence <- solution$convergence
if (convergence == 0) {
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
return(R)
}else{
warning("No convergence")
}
}
determine_radius(alpha = alpha, Ni_max = Ni_max, Nj_max = Nj_max)
alpha <- matrix(runif(4, -1,.5), ncol = 2, nrow = 2)
#arbitrary maximum abundances
Ni_max <- 300
Nj_max <- 800
determine_radius(alpha = alpha, Ni_max = Ni_max, Nj_max = Nj_max)
rr<-determine_radius(alpha = alpha, Ni_max = Ni_max, Nj_max = Nj_max)
rr
rr
rr
require(Rsolnp)
#to maximize f(x) is equivalent to minimizing -f(x)
# so this is a function that gives you -R^2
radius<- function(N, alpha, Ni_max, Nj_max){
#Where N[1] is Ni and N[2] is Nj
r1 = ( (N[1]*alpha[1,1]) + (N[2]*alpha[1,2]))^2
r2 = ( (N[1]*alpha[1,2]) + (N[2]*alpha[2,2]))^2
# remember that this actually gives you -R^2
R = - r1 - r2
return(R)
}
#Note that the main and constraint functions must take the exact same arguments, irrespective of whether they are used by all of them.
inequalities <- function(N,alpha, Ni_max, Nj_max) {
z1=  N[1] - Ni_max
z2=  N[2] - Nj_max
return(c(z1, z2))
}
#wrapper function that takes maximum values of abundances and the alpha matrix
#returns the value of R optimized
determine_radius<- function(alpha, Ni_max, Nj_max){
# Ni/Nj has to be equal or smaller than Ni_max
upper_constraints <- c(0,0)
# Ni/Nj has to be equal or greater than 0
lower_constraints <- c(-Ni_max,-Nj_max)
#initial params at the center not at the boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max)
convergence <- solution$convergence
if (convergence == 0) {
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
return(R)
}else{
warning("No convergence")
}
}
rr<-determine_radius(alpha = alpha, Ni_max = Ni_max, Nj_max = Nj_max)
rr
require(Rsolnp)
#to maximize f(x) is equivalent to minimizing -f(x)
# so this is a function that gives you -R^2
radius<- function(N, alpha, Ni_max, Nj_max){
#Where N[1] is Ni and N[2] is Nj
r1 = ( (N[1]*alpha[1,1]) + (N[2]*alpha[1,2]))^2
r2 = ( (N[1]*alpha[1,2]) + (N[2]*alpha[2,2]))^2
# remember that this actually gives you -R^2
R = - r1 - r2
return(R)
}
#Note that the main and constraint functions must take the exact same arguments, irrespective of whether they are used by all of them.
inequalities <- function(N,alpha, Ni_max, Nj_max) {
z1=  N[1] - Ni_max
z2=  N[2] - Nj_max
return(c(z1, z2))
}
#wrapper function that takes maximum values of abundances and the alpha matrix
#returns the value of R optimized
determine_radius<- function(alpha, Ni_max, Nj_max){
# Ni/Nj has to be equal or smaller than Ni_max
upper_constraints <- c(0,0)
# Ni/Nj has to be equal or greater than 0
lower_constraints <- c(-Ni_max,-Nj_max)
#initial params at the center not at the boundary
N0 = c(Ni_max/2,Nj_max/2)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max)
convergence <- solution$convergence
if (convergence == 0) {
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
return(R)
}else{
warning("No convergence")
}
}
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/determine_radius.R")
source("code/model_toolbox.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 1000,
Nj = 1000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
test_2
#to maximize f(x) is equivalent to minimizing -f(x)
# so this is a function that gives you -R^2
radius<- function(N, alpha, Ni_max, Nj_max){
#Where N[1] is Ni and N[2] is Nj
r1 = ( (N[1]*alpha[1,1]) + (N[2]*alpha[1,2]))^2
r2 = ( (N[1]*alpha[1,2]) + (N[2]*alpha[2,2]))^2
# remember that this actually gives you -R^2
R = - r1 - r2
return(R)
}
#Note that the main and constraint functions must take the exact same arguments, irrespective of whether they are used by all of them.
inequalities <- function(N,alpha, Ni_max, Nj_max) {
z1=  N[1] - Ni_max
z2=  N[2] - Nj_max
return(c(z1, z2))
}
#wrapper function that takes maximum values of abundances and the alpha matrix
#returns the value of R optimized
determine_radius<- function(alpha, Ni_max, Nj_max){
# Ni/Nj has to be equal or smaller than Ni_max
upper_constraints <- c(0,0)
# Ni/Nj has to be equal or greater than 0
lower_constraints <- c(-Ni_max,-Nj_max)
#initial params at the center not at the boundary
N0 = c(Ni_max/2,Nj_max/2)
ctrl <- list(TOL=1e-6, trace=0)
solution <- solnp(fun = radius,
pars = N0,
ineqfun = inequalities,
ineqUB = upper_constraints,
ineqLB = lower_constraints,
alpha = alpha,
Ni_max = Ni_max,
Nj_max = Nj_max,
control = ctrl)
convergence <- solution$convergence
if (convergence == 0) {
#we extract R
n <- length(solution$values)
value  <- solution$values[2]
R <- sqrt(-value)
return(R)
}else{
warning("No convergence")
}
}
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 1000,
Nj = 1000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
test_2
getwd()
setwd("./data/germination_data/")
setwd("./data/germination_data/")
rm(list = ls())
library(tidyverse)
library(lme4)
trcy_vero<-read_csv("data/trcy_vero.csv") %>%
dplyr::select(species, plot, light_treatment = `light/ dark`, plate_number = 'plate #',
num_seeds = '# seeds', emerged_inviable = 'emerged-inviable',
nongerm_filled = 'nongerminant-filled', nongerm_unfilled = 'nongerminant-unfilled',
no_radical = 'cotyledons only',
week_1 = 'week 1', week_2 = 'week 2', week_3 = 'week 3', week_4 = 'week 4', week_5 = 'week 5', cut_test_performed) %>%
dplyr::mutate(prop_germ = week_5/num_seeds)
getwd()
setwd( "/home/albacervantes/bayesian-competition/data/germination_data/data")
setwd( "/home/albacervantes/bayesian-competition")
getwd()
setwd("./data/germination_data")
rm(list = ls())
library(tidyverse)
library(lme4)
####bring in germiantion data
trcy_vero<-read_csv("data/trcy_vero.csv")
rm(list = ls())
library(tidyverse)
library(lme4)
####bring in germiantion data
trcy_vero<-read_csv("./data/trcy_vero.csv") %>%
dplyr::select(species, plot, light_treatment = `light/ dark`, plate_number = 'plate #',
num_seeds = '# seeds', emerged_inviable = 'emerged-inviable',
nongerm_filled = 'nongerminant-filled', nongerm_unfilled = 'nongerminant-unfilled',
no_radical = 'cotyledons only',
week_1 = 'week 1', week_2 = 'week 2', week_3 = 'week 3', week_4 = 'week 4', week_5 = 'week 5', cut_test_performed) %>%
dplyr::mutate(prop_germ = week_5/num_seeds)
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/determine_radius.R")
source("code/model_toolbox.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 10000,
Nj = 10000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
getwd()
setwd("/home/albacervantes/bayesian-competition")
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/determine_radius.R")
source("code/model_toolbox.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 10000,
Nj = 10000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
test_2
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_lv_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 10000,
Nj = 10000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/determine_radius.R")
source("code/model_toolbox.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_lv_multispecies_poisson.rds,
trcy_model = trcy_lv_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 10000,
Nj = 10000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 10000,
Nj = 10000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
source("code/read_models.R")
source("code/integration_toolbox.R")
source("code/determine_radius.R")
source("code/model_toolbox.R")
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_bh_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 1000,
Nj = 1000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
gi<-.372
si<-.556
gj<-.258
sj<-.033
ptm <- proc.time()
test_2<- posterior_feasibility(vero_model = vero_lv_multispecies_poisson.rds,
trcy_model = trcy_bh_multispecies_poisson.rds,
si = si,
gi = gi,
sj = sj,
gj = gj,
Ni = 1000,
Nj = 1000,
env = FALSE,
make_plot = TRUE)
proc.time() - ptm
